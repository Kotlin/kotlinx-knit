/*
 * Copyright 2016-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.
 */

package kotlinx.knit

import java.io.*
import java.nio.file.*
import kotlin.streams.*
import kotlin.test.*

private val TEST_DATA_DIR = Paths.get("testdata")
private val TEST_KT = Paths.get("test", "TestDataTest.kt")
private const val PROPERTIES_SUFFIX = ".properties"

private enum class TestCaseType(val inSuffix: String, val outSuffix: String) {
    MD(".in.md", ".out.md"),
    KT(".in.kt", ".out.kt")
}

private const val GENERATED_COMMENT = "// !!! AUTOMATICALLY GENERATED BY TestDataGen. DO NOT EDIT !!!"

/**
 * Writes [TestDataTest] based on the contents of `testdata` directory.
 */
fun main() {
    val out = PrintWriter(Files.newOutputStream(TEST_KT))
    out.println(GENERATED_COMMENT)
    out.println("package kotlinx.knit")
    out.println()
    out.println("import kotlin.test.Test")
    out.println()
    out.println("class TestDataTest {")
    val cases = ArrayList<Pair<TestCaseType, Path>>()
    for (type in TestCaseType.values()) {
        Files.newDirectoryStream(TEST_DATA_DIR, "*${type.inSuffix}").use {
            for (path in it) cases += type to path
        }
    }
    cases.sortedBy { it.second.fileName }.forEachIndexed { index, (type, inFile) ->
        if (index > 0) out.println()
        writeTest(out, type, inFile)
    }
    out.println("}")
    out.close()
}

private fun writeTest(out: PrintWriter, type: TestCaseType, inPath: Path) {
    // collect files
    val inFileName = inPath.fileName.toString()
    assertTrue(inFileName.endsWith(type.inSuffix))
    val testPrefix = inFileName.substring(0, inFileName.length - type.inSuffix.length)
    val testName = testPrefix.split("-").map { it.capitalize() }.joinToString("")
    val outPath = TEST_DATA_DIR.resolve(testPrefix + type.outSuffix).takeIfExists() ?: inPath
    val propsPath = TEST_DATA_DIR.resolve(testPrefix + PROPERTIES_SUFFIX).takeIfExists()
    val params = mutableListOf<Any?>(testName, inPath, outPath, propsPath)
    // additional copied files
    Files.newDirectoryStream(TEST_DATA_DIR, "$testPrefix.copy.*").use { dirEntries ->
        dirEntries.asSequence()
            .map { path -> FileRef.Copy(path.toUnixPath()) }
            .sortedBy { it.path }
            .toCollection(params)
    }
    // files from the "testPrefix" directory are expected
    val extraDir = inPath.parent.resolve(testPrefix)
    if (Files.exists(extraDir)) {
        Files.walk(extraDir).use { dirEntries ->
            dirEntries.asSequence()
                .filter { path -> Files.isRegularFile(path) }
                .map { path -> FileRef.Expect(path.toUnixPath()) }
                .sortedBy { it.path }
                .toCollection(params)
        }
    }
    // write test
    out.println("    $GENERATED_COMMENT")
    out.println("    @Test")
    out.println("    fun test$testName() {")
    out.println("       verifyTestData(")
    params.forEachIndexed { index, p -> out.printlnParam(p, index == params.lastIndex) }
    out.println("       )")
    out.println("    }")
}

private fun Path.toUnixPath(): String = toString().replace('\\', '/')

private fun PrintWriter.printlnParam(p: Any?, last: Boolean = false) {
    print("           ")
    when (p) {
        null -> print("null")
        is String -> print("\"$p\"")
        is Path -> print("\"${p.toUnixPath()}\"")
        is FileRef -> print(p)
        else -> error("Unsupported param type ${p::class}")
    }
    if (!last) print(",")
    println()
}

private fun Path.takeIfExists(): Path? =
    if (Files.exists(this)) this else null
